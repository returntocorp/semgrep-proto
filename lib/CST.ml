(* Generated by ocaml-tree-sitter. *)
(*
   proto grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type float_lit = Token.t

type decimal_lit = Token.t

type octal_lit = Token.t

type imm_tok_prec_p1_pat_dc28280 = Token.t (* pattern "[^'\\\\]+" *)

type identifier = Token.t

type key_type = [
    `Int32 of Token.t (* "int32" *)
  | `Int64 of Token.t (* "int64" *)
  | `Uint32 of Token.t (* "uint32" *)
  | `Uint64 of Token.t (* "uint64" *)
  | `Sint32 of Token.t (* "sint32" *)
  | `Sint64 of Token.t (* "sint64" *)
  | `Fixed32 of Token.t (* "fixed32" *)
  | `Fixed64 of Token.t (* "fixed64" *)
  | `Sfixed32 of Token.t (* "sfixed32" *)
  | `Sfixed64 of Token.t (* "sfixed64" *)
  | `Bool of Token.t (* "bool" *)
  | `Str of Token.t (* "string" *)
]

type escape_sequence = Token.t

type imm_tok_prec_p1_pat_3a2a380 = Token.t (* pattern "[^\"\\\\]+" *)

type anon_choice_DASH_81d4819 = [
    `DASH of Token.t (* "-" *)
  | `PLUS of Token.t (* "+" *)
]

type syntax = (
    Token.t (* "syntax" *) * Token.t (* "=" *) * Token.t (* "\"proto3\"" *)
  * Token.t (* ";" *)
)

type hex_lit = Token.t

type string_ = [
    `DQUOT_rep_choice_imm_tok_prec_p1_pat_3a2a380_DQUOT of (
        Token.t (* "\"" *)
      * [
            `Imm_tok_prec_p1_pat_3a2a380 of imm_tok_prec_p1_pat_3a2a380
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `SQUOT_rep_choice_imm_tok_prec_p1_pat_dc28280_SQUOT of (
        Token.t (* "'" *)
      * [
            `Imm_tok_prec_p1_pat_dc28280 of imm_tok_prec_p1_pat_dc28280
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "'" *)
    )
]

type bool_ = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]

type int_lit = [
    `Deci_lit of decimal_lit (*tok*)
  | `Octal_lit of octal_lit (*tok*)
  | `Hex_lit of hex_lit (*tok*)
]

type message_or_enum_type = (
    Token.t (* "." *) option
  * (identifier (*tok*) * Token.t (* "." *)) list (* zero or more *)
  * identifier (*tok*)
)

type field_names = (
    identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
)

type full_ident = (
    identifier (*tok*)
  * (Token.t (* "." *) * identifier (*tok*)) list (* zero or more *) option
)

type import = (
    Token.t (* "import" *)
  * [ `Weak of Token.t (* "weak" *) | `Public of Token.t (* "public" *) ]
      option
  * string_
  * Token.t (* ";" *)
)

type field_number = int_lit

type type_ = [
    `Double of Token.t (* "double" *)
  | `Float of Token.t (* "float" *)
  | `Int32 of Token.t (* "int32" *)
  | `Int64 of Token.t (* "int64" *)
  | `Uint32 of Token.t (* "uint32" *)
  | `Uint64 of Token.t (* "uint64" *)
  | `Sint32 of Token.t (* "sint32" *)
  | `Sint64 of Token.t (* "sint64" *)
  | `Fixed32 of Token.t (* "fixed32" *)
  | `Fixed64 of Token.t (* "fixed64" *)
  | `Sfixed32 of Token.t (* "sfixed32" *)
  | `Sfixed64 of Token.t (* "sfixed64" *)
  | `Bool of Token.t (* "bool" *)
  | `Str of Token.t (* "string" *)
  | `Bytes of Token.t (* "bytes" *)
  | `Mess_or_enum_type of message_or_enum_type
]

type package = (Token.t (* "package" *) * full_ident * Token.t (* ";" *))

type option_name = (
    [
        `Id of identifier (*tok*)
      | `LPAR_full_id_RPAR of (
            Token.t (* "(" *) * full_ident * Token.t (* ")" *)
        )
    ]
  * (Token.t (* "." *) * identifier (*tok*)) list (* zero or more *)
)

type constant = [
    `Full_id of full_ident
  | `Opt_choice_DASH_int_lit of (
        anon_choice_DASH_81d4819 option
      * field_number
    )
  | `Opt_choice_DASH_float_lit of (
        anon_choice_DASH_81d4819 option
      * float_lit (*tok*)
    )
  | `Str of string_
  | `Bool of bool_
  | `Blk_lit of (
        Token.t (* "{" *)
      * (
            identifier (*tok*)
          * Token.t (* ":" *) option
          * [
                `Cst of constant
              | `LBRACK_cst_rep_COMMA_cst_RBRACK of (
                    Token.t (* "[" *)
                  * constant
                  * (Token.t (* "," *) * constant) list (* zero or more *)
                  * Token.t (* "]" *)
                )
            ]
          * [ `COMMA of Token.t (* "," *) | `SEMI of Token.t (* ";" *) ]
              option
        )
          list (* zero or more *)
      * Token.t (* "}" *)
    )
]

type range = (
    field_number
  * (
        Token.t (* "to" *)
      * [ `Int_lit of field_number | `Max of Token.t (* "max" *) ]
    )
      option
)

type field_option = (option_name * Token.t (* "=" *) * constant)

type option_ = (
    Token.t (* "option" *) * option_name * Token.t (* "=" *) * constant
  * Token.t (* ";" *)
)

type enum_value_option = (option_name * Token.t (* "=" *) * constant)

type ranges = (range * (Token.t (* "," *) * range) list (* zero or more *))

type field_options = (
    field_option
  * (Token.t (* "," *) * field_option) list (* zero or more *)
)

type rpc = (
    Token.t (* "rpc" *)
  * identifier (*tok*)
  * Token.t (* "(" *)
  * Token.t (* "stream" *) option
  * message_or_enum_type
  * Token.t (* ")" *)
  * Token.t (* "returns" *)
  * Token.t (* "(" *)
  * Token.t (* "stream" *) option
  * message_or_enum_type
  * Token.t (* ")" *)
  * [
        `LCURL_rep_choice_opt_RCURL of (
            Token.t (* "{" *)
          * [ `Opt of option_ | `Empty_stmt of Token.t (* ";" *) ]
              list (* zero or more *)
          * Token.t (* "}" *)
        )
      | `SEMI of Token.t (* ";" *)
    ]
)

type enum_field = (
    identifier (*tok*)
  * Token.t (* "=" *)
  * Token.t (* "-" *) option
  * field_number
  * (
        Token.t (* "[" *)
      * enum_value_option
      * (Token.t (* "," *) * enum_value_option) list (* zero or more *)
      * Token.t (* "]" *)
    )
      option
  * Token.t (* ";" *)
)

type reserved = (
    Token.t (* "reserved" *)
  * [ `Ranges of ranges | `Field_names of field_names ]
  * Token.t (* ";" *)
)

type field = (
    Token.t (* "optional" *) option
  * Token.t (* "repeated" *) option
  * type_
  * identifier (*tok*)
  * Token.t (* "=" *)
  * field_number
  * (Token.t (* "[" *) * field_options * Token.t (* "]" *)) option
  * Token.t (* ";" *)
)

type map_field = (
    Token.t (* "map" *)
  * Token.t (* "<" *)
  * key_type
  * Token.t (* "," *)
  * type_
  * Token.t (* ">" *)
  * identifier (*tok*)
  * Token.t (* "=" *)
  * field_number
  * (Token.t (* "[" *) * field_options * Token.t (* "]" *)) option
  * Token.t (* ";" *)
)

type oneof_field = (
    type_
  * identifier (*tok*)
  * Token.t (* "=" *)
  * field_number
  * (Token.t (* "[" *) * field_options * Token.t (* "]" *)) option
)

type service = (
    Token.t (* "service" *)
  * identifier (*tok*)
  * Token.t (* "{" *)
  * [ `Opt of option_ | `Rpc of rpc | `Empty_stmt of Token.t (* ";" *) ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

type enum_body = (
    Token.t (* "{" *)
  * [
        `Opt of option_
      | `Enum_field of enum_field
      | `Empty_stmt of Token.t (* ";" *)
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

type oneof = (
    Token.t (* "oneof" *)
  * identifier (*tok*)
  * Token.t (* "{" *)
  * [
        `Opt of option_
      | `Oneof_field of oneof_field
      | `Empty_stmt of Token.t (* ";" *)
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

type enum = (Token.t (* "enum" *) * identifier (*tok*) * enum_body)

type message = (Token.t (* "message" *) * identifier (*tok*) * message_body)

and message_body = (
    Token.t (* "{" *)
  * [
        `Field of field
      | `Enum of enum
      | `Mess of message
      | `Opt of option_
      | `Oneof of oneof
      | `Map_field of map_field
      | `Rese of reserved
      | `Empty_stmt of Token.t (* ";" *)
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

type source_file = (
    syntax
  * [
        `Import of import
      | `Pack of package
      | `Opt of option_
      | `Enum of enum
      | `Mess of message
      | `Serv of service
      | `Empty_stmt of Token.t (* ";" *)
    ]
      list (* zero or more *)
      option
)

type false_ (* inlined *) = Token.t (* "false" *)

type comment (* inlined *) = Token.t

type true_ (* inlined *) = Token.t (* "true" *)

type empty_statement (* inlined *) = Token.t (* ";" *)

type enum_name (* inlined *) = identifier (*tok*)

type rpc_name (* inlined *) = identifier (*tok*)

type message_name (* inlined *) = identifier (*tok*)

type service_name (* inlined *) = identifier (*tok*)

type block_lit (* inlined *) = (
    Token.t (* "{" *)
  * (
        identifier (*tok*)
      * Token.t (* ":" *) option
      * [
            `Cst of constant
          | `LBRACK_cst_rep_COMMA_cst_RBRACK of (
                Token.t (* "[" *)
              * constant
              * (Token.t (* "," *) * constant) list (* zero or more *)
              * Token.t (* "]" *)
            )
        ]
      * [ `COMMA of Token.t (* "," *) | `SEMI of Token.t (* ";" *) ] option
    )
      list (* zero or more *)
  * Token.t (* "}" *)
)

type extra = Comment of Loc.t * comment

type extras = extra list
